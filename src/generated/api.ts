/* tslint:disable */
/* eslint-disable */
/**
 * airtableFour
 * Connector to read and write data in Airtable. Airtable is a cloud-based spreadsheet-like service that enables users to collaborate and manage different types of data. It is easy-to-use and can act as database or CRM (Customer Relationship Management). It can also be used as project planning, tracking inventory.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: Woong.Choi@sevensigma.com.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Records
     * @type {Array<InlineResponse200Records>}
     * @memberof InlineResponse200
     */
    records?: Array<InlineResponse200Records>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * id
     * @type {string}
     * @memberof InlineResponse2001
     */
    id?: string;
    /**
     * deleted
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    deleted?: boolean;
    /**
     * 
     * @type {InlineResponse2001Error}
     * @memberof InlineResponse2001
     */
    error?: InlineResponse2001Error;
}
/**
 * error
 * @export
 * @interface InlineResponse2001Error
 */
export interface InlineResponse2001Error {
    /**
     * type
     * @type {string}
     * @memberof InlineResponse2001Error
     */
    type?: string;
    /**
     * message
     * @type {string}
     * @memberof InlineResponse2001Error
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * id
     * @type {string}
     * @memberof InlineResponse2002
     */
    id?: string;
    /**
     * Record Created Time
     * @type {string}
     * @memberof InlineResponse2002
     */
    createdTime?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Records
 */
export interface InlineResponse200Records {
    /**
     * Record ID
     * @type {string}
     * @memberof InlineResponse200Records
     */
    id?: string;
    /**
     * Record Created Time
     * @type {string}
     * @memberof InlineResponse200Records
     */
    createdTime?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a record in a table. JSON record needs to be passed.
         * @summary Create a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} contentType Content-Type for the body of the request. It is defaulted to JSON.
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaRecord: async (baseID: string, table: string, contentType: string, authorization: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseID' is not null or undefined
            assertParamExists('createaRecord', 'baseID', baseID)
            // verify required parameter 'table' is not null or undefined
            assertParamExists('createaRecord', 'table', table)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createaRecord', 'contentType', contentType)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createaRecord', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createaRecord', 'body', body)
            const localVarPath = `/{Base ID}/{Table}`
                .replace(`{${"Base ID"}}`, encodeURIComponent(String(baseID)))
                .replace(`{${"Table"}}`, encodeURIComponent(String(table)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a record in a table. Provide Record ID to select a record.
         * @summary Delete a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be deleted.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaRecord: async (baseID: string, table: string, recordID: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseID' is not null or undefined
            assertParamExists('deleteaRecord', 'baseID', baseID)
            // verify required parameter 'table' is not null or undefined
            assertParamExists('deleteaRecord', 'table', table)
            // verify required parameter 'recordID' is not null or undefined
            assertParamExists('deleteaRecord', 'recordID', recordID)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteaRecord', 'authorization', authorization)
            const localVarPath = `/{Base ID}/{Table}/{Record ID}`
                .replace(`{${"Base ID"}}`, encodeURIComponent(String(baseID)))
                .replace(`{${"Table"}}`, encodeURIComponent(String(table)))
                .replace(`{${"Record ID"}}`, encodeURIComponent(String(recordID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Records in table. Returned records do not include any fields with empty values. You can filter, sort, and format the results with the parameters.
         * @summary List Records
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} authorization 
         * @param {string} [filterByFormula] A formula used to filter records.
         * @param {number} [maxRecords] The maximum total number of records that will be returned in your requests.
         * @param {number} [pageSize] The number of records returned in each request. Must be less than or equal to 100.
         * @param {string} [view] The name or ID of a view in the table. If set, only the records in that view will be returned.
         * @param {string} [cellFormat] The format that should be used for cell values. Supported values are: json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type.
         * @param {string} [timeZone] The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {string} [userLocale] The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords: async (baseID: string, table: string, authorization: string, filterByFormula?: string, maxRecords?: number, pageSize?: number, view?: string, cellFormat?: string, timeZone?: string, userLocale?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseID' is not null or undefined
            assertParamExists('listRecords', 'baseID', baseID)
            // verify required parameter 'table' is not null or undefined
            assertParamExists('listRecords', 'table', table)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listRecords', 'authorization', authorization)
            const localVarPath = `/{Base ID}/{Table}`
                .replace(`{${"Base ID"}}`, encodeURIComponent(String(baseID)))
                .replace(`{${"Table"}}`, encodeURIComponent(String(table)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterByFormula !== undefined) {
                localVarQueryParameter['filterByFormula'] = filterByFormula;
            }

            if (maxRecords !== undefined) {
                localVarQueryParameter['maxRecords'] = maxRecords;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (cellFormat !== undefined) {
                localVarQueryParameter['cellFormat'] = cellFormat;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (userLocale !== undefined) {
                localVarQueryParameter['userLocale'] = userLocale;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a record in a table. Any empty fields (e.g. [], or false) in the record will not be returned.
         * @summary Retrieve a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be retrieved.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveaRecord: async (baseID: string, table: string, recordID: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseID' is not null or undefined
            assertParamExists('retrieveaRecord', 'baseID', baseID)
            // verify required parameter 'table' is not null or undefined
            assertParamExists('retrieveaRecord', 'table', table)
            // verify required parameter 'recordID' is not null or undefined
            assertParamExists('retrieveaRecord', 'recordID', recordID)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('retrieveaRecord', 'authorization', authorization)
            const localVarPath = `/{Base ID}/{Table}/{Record ID}`
                .replace(`{${"Base ID"}}`, encodeURIComponent(String(baseID)))
                .replace(`{${"Table"}}`, encodeURIComponent(String(table)))
                .replace(`{${"Record ID"}}`, encodeURIComponent(String(recordID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a record in a table. It will only update the fields provided and leave the rest as they were.
         * @summary Update a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be updated
         * @param {string} authorization 
         * @param {object} body 
         * @param {string} [contentType] Content-Type for the body of the request. It is defaulted to JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaRecord: async (baseID: string, table: string, recordID: string, authorization: string, body: object, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseID' is not null or undefined
            assertParamExists('updateaRecord', 'baseID', baseID)
            // verify required parameter 'table' is not null or undefined
            assertParamExists('updateaRecord', 'table', table)
            // verify required parameter 'recordID' is not null or undefined
            assertParamExists('updateaRecord', 'recordID', recordID)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateaRecord', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateaRecord', 'body', body)
            const localVarPath = `/{Base ID}/{Table}/{Record ID}`
                .replace(`{${"Base ID"}}`, encodeURIComponent(String(baseID)))
                .replace(`{${"Table"}}`, encodeURIComponent(String(table)))
                .replace(`{${"Record ID"}}`, encodeURIComponent(String(recordID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a record in a table. JSON record needs to be passed.
         * @summary Create a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} contentType Content-Type for the body of the request. It is defaulted to JSON.
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createaRecord(baseID: string, table: string, contentType: string, authorization: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200Records>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createaRecord(baseID, table, contentType, authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a record in a table. Provide Record ID to select a record.
         * @summary Delete a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be deleted.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteaRecord(baseID, table, recordID, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Records in table. Returned records do not include any fields with empty values. You can filter, sort, and format the results with the parameters.
         * @summary List Records
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} authorization 
         * @param {string} [filterByFormula] A formula used to filter records.
         * @param {number} [maxRecords] The maximum total number of records that will be returned in your requests.
         * @param {number} [pageSize] The number of records returned in each request. Must be less than or equal to 100.
         * @param {string} [view] The name or ID of a view in the table. If set, only the records in that view will be returned.
         * @param {string} [cellFormat] The format that should be used for cell values. Supported values are: json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type.
         * @param {string} [timeZone] The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {string} [userLocale] The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecords(baseID: string, table: string, authorization: string, filterByFormula?: string, maxRecords?: number, pageSize?: number, view?: string, cellFormat?: string, timeZone?: string, userLocale?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecords(baseID, table, authorization, filterByFormula, maxRecords, pageSize, view, cellFormat, timeZone, userLocale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a record in a table. Any empty fields (e.g. [], or false) in the record will not be returned.
         * @summary Retrieve a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be retrieved.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200Records>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveaRecord(baseID, table, recordID, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a record in a table. It will only update the fields provided and leave the rest as they were.
         * @summary Update a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be updated
         * @param {string} authorization 
         * @param {object} body 
         * @param {string} [contentType] Content-Type for the body of the request. It is defaulted to JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateaRecord(baseID: string, table: string, recordID: string, authorization: string, body: object, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateaRecord(baseID, table, recordID, authorization, body, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create a record in a table. JSON record needs to be passed.
         * @summary Create a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} contentType Content-Type for the body of the request. It is defaulted to JSON.
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createaRecord(baseID: string, table: string, contentType: string, authorization: string, body: object, options?: any): AxiosPromise<InlineResponse200Records> {
            return localVarFp.createaRecord(baseID, table, contentType, authorization, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a record in a table. Provide Record ID to select a record.
         * @summary Delete a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be deleted.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.deleteaRecord(baseID, table, recordID, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * List Records in table. Returned records do not include any fields with empty values. You can filter, sort, and format the results with the parameters.
         * @summary List Records
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} authorization 
         * @param {string} [filterByFormula] A formula used to filter records.
         * @param {number} [maxRecords] The maximum total number of records that will be returned in your requests.
         * @param {number} [pageSize] The number of records returned in each request. Must be less than or equal to 100.
         * @param {string} [view] The name or ID of a view in the table. If set, only the records in that view will be returned.
         * @param {string} [cellFormat] The format that should be used for cell values. Supported values are: json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type.
         * @param {string} [timeZone] The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {string} [userLocale] The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords(baseID: string, table: string, authorization: string, filterByFormula?: string, maxRecords?: number, pageSize?: number, view?: string, cellFormat?: string, timeZone?: string, userLocale?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.listRecords(baseID, table, authorization, filterByFormula, maxRecords, pageSize, view, cellFormat, timeZone, userLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a record in a table. Any empty fields (e.g. [], or false) in the record will not be returned.
         * @summary Retrieve a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be retrieved.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any): AxiosPromise<InlineResponse200Records> {
            return localVarFp.retrieveaRecord(baseID, table, recordID, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a record in a table. It will only update the fields provided and leave the rest as they were.
         * @summary Update a record
         * @param {string} baseID Base ID
         * @param {string} table Table name
         * @param {string} recordID Record ID to be updated
         * @param {string} authorization 
         * @param {object} body 
         * @param {string} [contentType] Content-Type for the body of the request. It is defaulted to JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateaRecord(baseID: string, table: string, recordID: string, authorization: string, body: object, contentType?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.updateaRecord(baseID, table, recordID, authorization, body, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a record in a table. JSON record needs to be passed.
     * @summary Create a record
     * @param {string} baseID Base ID
     * @param {string} table Table name
     * @param {string} contentType Content-Type for the body of the request. It is defaulted to JSON.
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createaRecord(baseID: string, table: string, contentType: string, authorization: string, body: object, options?: any) {
        return DefaultApiFp(this.configuration).createaRecord(baseID, table, contentType, authorization, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a record in a table. Provide Record ID to select a record.
     * @summary Delete a record
     * @param {string} baseID Base ID
     * @param {string} table Table name
     * @param {string} recordID Record ID to be deleted.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteaRecord(baseID, table, recordID, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Records in table. Returned records do not include any fields with empty values. You can filter, sort, and format the results with the parameters.
     * @summary List Records
     * @param {string} baseID Base ID
     * @param {string} table Table name
     * @param {string} authorization 
     * @param {string} [filterByFormula] A formula used to filter records.
     * @param {number} [maxRecords] The maximum total number of records that will be returned in your requests.
     * @param {number} [pageSize] The number of records returned in each request. Must be less than or equal to 100.
     * @param {string} [view] The name or ID of a view in the table. If set, only the records in that view will be returned.
     * @param {string} [cellFormat] The format that should be used for cell values. Supported values are: json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type.
     * @param {string} [timeZone] The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
     * @param {string} [userLocale] The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listRecords(baseID: string, table: string, authorization: string, filterByFormula?: string, maxRecords?: number, pageSize?: number, view?: string, cellFormat?: string, timeZone?: string, userLocale?: string, options?: any) {
        return DefaultApiFp(this.configuration).listRecords(baseID, table, authorization, filterByFormula, maxRecords, pageSize, view, cellFormat, timeZone, userLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a record in a table. Any empty fields (e.g. [], or false) in the record will not be returned.
     * @summary Retrieve a record
     * @param {string} baseID Base ID
     * @param {string} table Table name
     * @param {string} recordID Record ID to be retrieved.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public retrieveaRecord(baseID: string, table: string, recordID: string, authorization: string, options?: any) {
        return DefaultApiFp(this.configuration).retrieveaRecord(baseID, table, recordID, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a record in a table. It will only update the fields provided and leave the rest as they were.
     * @summary Update a record
     * @param {string} baseID Base ID
     * @param {string} table Table name
     * @param {string} recordID Record ID to be updated
     * @param {string} authorization 
     * @param {object} body 
     * @param {string} [contentType] Content-Type for the body of the request. It is defaulted to JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateaRecord(baseID: string, table: string, recordID: string, authorization: string, body: object, contentType?: string, options?: any) {
        return DefaultApiFp(this.configuration).updateaRecord(baseID, table, recordID, authorization, body, contentType, options).then((request) => request(this.axios, this.basePath));
    }
}



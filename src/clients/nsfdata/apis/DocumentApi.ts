/* tslint:disable */
/* eslint-disable */
/**
 * NSF Data
 * NSF Data Connector provides access to any HCL Domino NSF database as well as IBM Domino NSF database (from version 9.0.1) for which Domino Access Services (DAS) are enabled. The Connector represents NSF databases, views, view entries, and documents in JSON format.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: nsf.data@databoat.ch
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Document,
    DocumentFromJSON,
    DocumentToJSON,
} from '../models';

export interface CreateDocumentRequest {
    folder: string;
    database: string;
    document: Document;
    form?: string;
    computewithform?: boolean;
    parentid?: string;
}

export interface DeleteDocumentRequest {
    folder: string;
    database: string;
    docUnid: string;
    ifUnmodifiedSince?: string;
}

export interface GetDocumentRequest {
    folder: string;
    database: string;
    docUnid: string;
    hidden?: boolean;
    multipart?: boolean;
    strongtype?: boolean;
    lowercasefields?: boolean;
    fields?: string;
    markread?: boolean;
    attachmentlinks?: boolean;
    ifModifiedSince?: string;
}

export interface UpdateDocumentRequest {
    folder: string;
    database: string;
    docUnid: string;
    document: Document;
    form?: string;
    computewithform?: boolean;
    ifUnmodifiedSince?: string;
}

export interface UpdateDocumentItemsRequest {
    folder: string;
    database: string;
    docUnid: string;
    document: Document;
    form?: string;
    computewithform?: boolean;
    ifUnmodifiedSince?: string;
}

/**
 * 
 */
export class DocumentApi extends runtime.BaseAPI {

    /**
     * Creates a new document
     * Creates a new document
     */
    async createDocumentRaw(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.folder === null || requestParameters.folder === undefined) {
            throw new runtime.RequiredError('folder','Required parameter requestParameters.folder was null or undefined when calling createDocument.');
        }

        if (requestParameters.database === null || requestParameters.database === undefined) {
            throw new runtime.RequiredError('database','Required parameter requestParameters.database was null or undefined when calling createDocument.');
        }

        if (requestParameters.document === null || requestParameters.document === undefined) {
            throw new runtime.RequiredError('document','Required parameter requestParameters.document was null or undefined when calling createDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.form !== undefined) {
            queryParameters['form'] = requestParameters.form;
        }

        if (requestParameters.computewithform !== undefined) {
            queryParameters['computewithform'] = requestParameters.computewithform;
        }

        if (requestParameters.parentid !== undefined) {
            queryParameters['parentid'] = requestParameters.parentid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{folder}/{database}/api/data/documents`.replace(`{${"folder"}}`, encodeURIComponent(String(requestParameters.folder))).replace(`{${"database"}}`, encodeURIComponent(String(requestParameters.database))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new document
     * Creates a new document
     */
    async createDocument(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.createDocumentRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a document
     * Deletes a document
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.folder === null || requestParameters.folder === undefined) {
            throw new runtime.RequiredError('folder','Required parameter requestParameters.folder was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.database === null || requestParameters.database === undefined) {
            throw new runtime.RequiredError('database','Required parameter requestParameters.database was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.docUnid === null || requestParameters.docUnid === undefined) {
            throw new runtime.RequiredError('docUnid','Required parameter requestParameters.docUnid was null or undefined when calling deleteDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifUnmodifiedSince !== undefined && requestParameters.ifUnmodifiedSince !== null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters.ifUnmodifiedSince);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{folder}/{database}/api/data/documents/unid/{docUnid}`.replace(`{${"folder"}}`, encodeURIComponent(String(requestParameters.folder))).replace(`{${"database"}}`, encodeURIComponent(String(requestParameters.database))).replace(`{${"docUnid"}}`, encodeURIComponent(String(requestParameters.docUnid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a document
     * Deletes a document
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteDocumentRaw(requestParameters, initOverrides);
    }

    /**
     * Reads a document
     * Reads a document
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.folder === null || requestParameters.folder === undefined) {
            throw new runtime.RequiredError('folder','Required parameter requestParameters.folder was null or undefined when calling getDocument.');
        }

        if (requestParameters.database === null || requestParameters.database === undefined) {
            throw new runtime.RequiredError('database','Required parameter requestParameters.database was null or undefined when calling getDocument.');
        }

        if (requestParameters.docUnid === null || requestParameters.docUnid === undefined) {
            throw new runtime.RequiredError('docUnid','Required parameter requestParameters.docUnid was null or undefined when calling getDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.hidden !== undefined) {
            queryParameters['hidden'] = requestParameters.hidden;
        }

        if (requestParameters.multipart !== undefined) {
            queryParameters['multipart'] = requestParameters.multipart;
        }

        if (requestParameters.strongtype !== undefined) {
            queryParameters['strongtype'] = requestParameters.strongtype;
        }

        if (requestParameters.lowercasefields !== undefined) {
            queryParameters['lowercasefields'] = requestParameters.lowercasefields;
        }

        if (requestParameters.fields !== undefined) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.markread !== undefined) {
            queryParameters['markread'] = requestParameters.markread;
        }

        if (requestParameters.attachmentlinks !== undefined) {
            queryParameters['attachmentlinks'] = requestParameters.attachmentlinks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifModifiedSince !== undefined && requestParameters.ifModifiedSince !== null) {
            headerParameters['If-Modified-Since'] = String(requestParameters.ifModifiedSince);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{folder}/{database}/api/data/documents/unid/{docUnid}`.replace(`{${"folder"}}`, encodeURIComponent(String(requestParameters.folder))).replace(`{${"database"}}`, encodeURIComponent(String(requestParameters.database))).replace(`{${"docUnid"}}`, encodeURIComponent(String(requestParameters.docUnid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Reads a document
     * Reads a document
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit): Promise<Document> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replaces all items in a document
     * Replaces all items in a document
     */
    async updateDocumentRaw(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.folder === null || requestParameters.folder === undefined) {
            throw new runtime.RequiredError('folder','Required parameter requestParameters.folder was null or undefined when calling updateDocument.');
        }

        if (requestParameters.database === null || requestParameters.database === undefined) {
            throw new runtime.RequiredError('database','Required parameter requestParameters.database was null or undefined when calling updateDocument.');
        }

        if (requestParameters.docUnid === null || requestParameters.docUnid === undefined) {
            throw new runtime.RequiredError('docUnid','Required parameter requestParameters.docUnid was null or undefined when calling updateDocument.');
        }

        if (requestParameters.document === null || requestParameters.document === undefined) {
            throw new runtime.RequiredError('document','Required parameter requestParameters.document was null or undefined when calling updateDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.form !== undefined) {
            queryParameters['form'] = requestParameters.form;
        }

        if (requestParameters.computewithform !== undefined) {
            queryParameters['computewithform'] = requestParameters.computewithform;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifUnmodifiedSince !== undefined && requestParameters.ifUnmodifiedSince !== null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters.ifUnmodifiedSince);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{folder}/{database}/api/data/documents/unid/{docUnid}`.replace(`{${"folder"}}`, encodeURIComponent(String(requestParameters.folder))).replace(`{${"database"}}`, encodeURIComponent(String(requestParameters.database))).replace(`{${"docUnid"}}`, encodeURIComponent(String(requestParameters.docUnid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Replaces all items in a document
     * Replaces all items in a document
     */
    async updateDocument(requestParameters: UpdateDocumentRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateDocumentRaw(requestParameters, initOverrides);
    }

    /**
     * Updates selected items in a document
     * Updates selected items in a document
     */
    async updateDocumentItemsRaw(requestParameters: UpdateDocumentItemsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.folder === null || requestParameters.folder === undefined) {
            throw new runtime.RequiredError('folder','Required parameter requestParameters.folder was null or undefined when calling updateDocumentItems.');
        }

        if (requestParameters.database === null || requestParameters.database === undefined) {
            throw new runtime.RequiredError('database','Required parameter requestParameters.database was null or undefined when calling updateDocumentItems.');
        }

        if (requestParameters.docUnid === null || requestParameters.docUnid === undefined) {
            throw new runtime.RequiredError('docUnid','Required parameter requestParameters.docUnid was null or undefined when calling updateDocumentItems.');
        }

        if (requestParameters.document === null || requestParameters.document === undefined) {
            throw new runtime.RequiredError('document','Required parameter requestParameters.document was null or undefined when calling updateDocumentItems.');
        }

        const queryParameters: any = {};

        if (requestParameters.form !== undefined) {
            queryParameters['form'] = requestParameters.form;
        }

        if (requestParameters.computewithform !== undefined) {
            queryParameters['computewithform'] = requestParameters.computewithform;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.ifUnmodifiedSince !== undefined && requestParameters.ifUnmodifiedSince !== null) {
            headerParameters['If-Unmodified-Since'] = String(requestParameters.ifUnmodifiedSince);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/{folder}/{database}/api/data/documents/unid/{docUnid}`.replace(`{${"folder"}}`, encodeURIComponent(String(requestParameters.folder))).replace(`{${"database"}}`, encodeURIComponent(String(requestParameters.database))).replace(`{${"docUnid"}}`, encodeURIComponent(String(requestParameters.docUnid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.document),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates selected items in a document
     * Updates selected items in a document
     */
    async updateDocumentItems(requestParameters: UpdateDocumentItemsRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateDocumentItemsRaw(requestParameters, initOverrides);
    }

}

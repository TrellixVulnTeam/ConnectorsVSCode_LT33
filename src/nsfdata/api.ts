/* tslint:disable */
/* eslint-disable */
/**
 * NSF Data s
 * NSF Data Connector provides access to any HCL Domino NSF database as well as IBM Domino NSF database (from version 9.0.1) for which Domino Access Services (DAS) are enabled. The Connector represents NSF databases, views, view entries, and documents in JSON format.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: nsf.data@databoat.ch
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * Title of the database.
     * @type {string}
     * @memberof Database
     */
    title?: string;
    /**
     * File path of the database relative to the Domino data directory.
     * @type {string}
     * @memberof Database
     */
    filepath?: string;
    /**
     * Replica ID of the database.
     * @type {string}
     * @memberof Database
     */
    replicaid?: string;
    /**
     * File name of the design template of the database, or an empty string if the database does not have a design template. 
     * @type {string}
     * @memberof Database
     */
    template?: string;
    /**
     * The URL of the view list resource for the database.
     * @type {string}
     * @memberof Database
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface DatabaseListResponse
 */
export interface DatabaseListResponse extends Array<Database> {
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    [key: string]: object | any;

    /**
     * The date the document was created.
     * @type {string}
     * @memberof Document
     */
    created?: string;
    /**
     * The last modification date of the document.
     * @type {string}
     * @memberof Document
     */
    modified?: string;
    /**
     * The universal ID of the document.
     * @type {string}
     * @memberof Document
     */
    unid?: string;
    /**
     * The note ID of the document.
     * @type {string}
     * @memberof Document
     */
    noteid?: string;
    /**
     * The URL of the Document resource.
     * @type {string}
     * @memberof Document
     */
    href?: string;
    /**
     * The name of the form used to create the document.
     * @type {string}
     * @memberof Document
     */
    form?: string;
}
/**
 * 
 * @export
 * @interface DocumentListEntry
 */
export interface DocumentListEntry {
    /**
     * The last modification date of the document.
     * @type {string}
     * @memberof DocumentListEntry
     */
    modified?: string;
    /**
     * The universal ID of the document.
     * @type {string}
     * @memberof DocumentListEntry
     */
    unid?: string;
    /**
     * The URL of the Document resource.
     * @type {string}
     * @memberof DocumentListEntry
     */
    href?: string;
    /**
     * The search score if this entry is in a search response.
     * @type {number}
     * @memberof DocumentListEntry
     */
    score?: number;
}
/**
 * 
 * @export
 * @interface DocumentListResponse
 */
export interface DocumentListResponse extends Array<DocumentListEntry> {
}
/**
 * 
 * @export
 * @interface FolderOperations
 */
export interface FolderOperations {
    /**
     * Array of UNIDs of documents to add to the folder.
     * @type {Array<string>}
     * @memberof FolderOperations
     */
    add?: Array<string>;
    /**
     * Array of UNIDs of documents to remove from the folder.
     * @type {Array<string>}
     * @memberof FolderOperations
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * Relationship to this resource.
     * @type {string}
     * @memberof Link
     */
    rel?: string;
    /**
     * URL to linked resource.
     * @type {string}
     * @memberof Link
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * Title of the view or folder.
     * @type {string}
     * @memberof View
     */
    title?: string;
    /**
     * `false` for a view, `true` for a folder. 
     * @type {boolean}
     * @memberof View
     */
    folder?: boolean;
    /**
     * `false` for shared, `true` for private. 
     * @type {boolean}
     * @memberof View
     */
    _private?: boolean;
    /**
     * Last modification date and time for the view or folder. 
     * @type {string}
     * @memberof View
     */
    modified?: string;
    /**
     * Universal ID of the view or folder.
     * @type {string}
     * @memberof View
     */
    unid?: string;
    /**
     * The URL of the corresponding view entry list resource.
     * @type {string}
     * @memberof View
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface ViewColumnDesign
 */
export interface ViewColumnDesign {
    /**
     * Position of the column in the view or folder, where 1 is the first column. 
     * @type {number}
     * @memberof ViewColumnDesign
     */
    columnnumber?: number;
    /**
     * The name of the column. 
     * @type {string}
     * @memberof ViewColumnDesign
     */
    name?: string;
    /**
     * The title of the column. 
     * @type {string}
     * @memberof ViewColumnDesign
     */
    title?: string;
    /**
     * The width of the column. 
     * @type {number}
     * @memberof ViewColumnDesign
     */
    width?: number;
    /**
     * The alignment of the column. 
     * @type {number}
     * @memberof ViewColumnDesign
     */
    alignment?: number;
    /**
     * `true` if the column is hidden. 
     * @type {boolean}
     * @memberof ViewColumnDesign
     */
    hidden?: boolean;
    /**
     * `true` if the column is for responses. 
     * @type {boolean}
     * @memberof ViewColumnDesign
     */
    response?: boolean;
    /**
     * `true` if the column is a twistie. 
     * @type {boolean}
     * @memberof ViewColumnDesign
     */
    twistie?: boolean;
    /**
     * `true` if the column is a field. 
     * @type {boolean}
     * @memberof ViewColumnDesign
     */
    field?: boolean;
    /**
     * `true` if the column is a category. 
     * @type {boolean}
     * @memberof ViewColumnDesign
     */
    category?: boolean;
}
/**
 * 
 * @export
 * @interface ViewDesignResponse
 */
export interface ViewDesignResponse extends Array<ViewColumnDesign> {
}
/**
 * 
 * @export
 * @interface ViewEntry
 */
export interface ViewEntry {
    [key: string]: object | any;

    /**
     * Position of the entry in the view or folder and the universal ID of any associated document. 
     * @type {string}
     * @memberof ViewEntry
     */
    entryid?: string;
    /**
     * The note ID of the document associated with the entry, or an empty string if the entry is a category or total (systemcolumns bit 0x0001). 
     * @type {string}
     * @memberof ViewEntry
     */
    noteid?: string;
    /**
     * The universal ID of the document associated with the entry,  or an empty string if the entry is a category or total (systemcolumns bit 0x0002). 
     * @type {string}
     * @memberof ViewEntry
     */
    unid?: string;
    /**
     * Position of the entry in the view or folder (systemcolumns bit 0x0004). 
     * @type {string}
     * @memberof ViewEntry
     */
    position?: string;
    /**
     * `true` if the entry is marked read for the user (systemcolumns bit 0x0008). 
     * @type {boolean}
     * @memberof ViewEntry
     */
    read?: boolean;
    /**
     * The number of siblings of the entry (systemcolumns bit 0x0010). 
     * @type {number}
     * @memberof ViewEntry
     */
    siblings?: number;
    /**
     * The number of descendants of the entry (systemcolumns bit 0x0020). 
     * @type {number}
     * @memberof ViewEntry
     */
    descendants?: number;
    /**
     * The number of children of the entry (systemcolumns bit 0x0040). 
     * @type {number}
     * @memberof ViewEntry
     */
    children?: number;
    /**
     * The indent level of the entry (systemcolumns bit 0x0080). 
     * @type {number}
     * @memberof ViewEntry
     */
    indent?: number;
    /**
     * The form upon which the document is based (systemcolumns bit 0x0100). 
     * @type {string}
     * @memberof ViewEntry
     */
    form?: string;
    /**
     * `true` if the entry is a category (systemcolumns bit 0x0200). 
     * @type {boolean}
     * @memberof ViewEntry
     */
    category?: boolean;
    /**
     * `true` if the entry is a response (systemcolumns bit 0x0400). 
     * @type {boolean}
     * @memberof ViewEntry
     */
    response?: boolean;
    /**
     * URL for the entry (systemcolumns bit 0x0800). 
     * @type {string}
     * @memberof ViewEntry
     */
    href?: string;
    /**
     * 
     * @type {Link}
     * @memberof ViewEntry
     */
    link?: Link;
    /**
     * The search score if this entry is in a search response (systemcolumns bit 0x2000). 
     * @type {number}
     * @memberof ViewEntry
     */
    score?: number;
}
/**
 * 
 * @export
 * @interface ViewEntryListResponse
 */
export interface ViewEntryListResponse extends Array<ViewEntry> {
}
/**
 * 
 * @export
 * @interface ViewListResponse
 */
export interface ViewListResponse extends Array<View> {
}

/**
 * AttachmentApi - axios parameter creator
 * @export
 */
export const AttachmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an attachment
         * @summary Deletes an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('deleteAttachment', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('deleteAttachment', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('deleteAttachment', 'docUnid', docUnid)
            // verify required parameter 'itemName' is not null or undefined
            assertParamExists('deleteAttachment', 'itemName', itemName)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteAttachment', 'fileName', fileName)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteAttachment', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}/{itemName}/{fileName}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)))
                .replace(`{${"itemName"}}`, encodeURIComponent(String(itemName)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads an attachment
         * @summary Reads an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getAttachment', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getAttachment', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('getAttachment', 'docUnid', docUnid)
            // verify required parameter 'itemName' is not null or undefined
            assertParamExists('getAttachment', 'itemName', itemName)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getAttachment', 'fileName', fileName)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAttachment', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}/{itemName}/{fileName}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)))
                .replace(`{${"itemName"}}`, encodeURIComponent(String(itemName)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentApi - functional programming interface
 * @export
 */
export const AttachmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an attachment
         * @summary Deletes an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(folder, database, docUnid, itemName, fileName, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads an attachment
         * @summary Reads an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(folder, database, docUnid, itemName, fileName, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AttachmentApi - factory interface
 * @export
 */
export const AttachmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentApiFp(configuration)
    return {
        /**
         * Deletes an attachment
         * @summary Deletes an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(folder, database, docUnid, itemName, fileName, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Reads an attachment
         * @summary Reads an attachment
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} itemName Name of the item associated with the attachment.
         * @param {string} fileName Attachment file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAttachment(folder, database, docUnid, itemName, fileName, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentApi - object-oriented interface
 * @export
 * @class AttachmentApi
 * @extends {BaseAPI}
 */
export class AttachmentApi extends BaseAPI {
    /**
     * Deletes an attachment
     * @summary Deletes an attachment
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} itemName Name of the item associated with the attachment.
     * @param {string} fileName Attachment file name.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public deleteAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any) {
        return AttachmentApiFp(this.configuration).deleteAttachment(folder, database, docUnid, itemName, fileName, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads an attachment
     * @summary Reads an attachment
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} itemName Name of the item associated with the attachment.
     * @param {string} fileName Attachment file name.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public getAttachment(folder: string, database: string, docUnid: string, itemName: string, fileName: string, authorization: string, options?: any) {
        return AttachmentApiFp(this.configuration).getAttachment(folder, database, docUnid, itemName, fileName, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseListApi - axios parameter creator
 * @export
 */
export const DatabaseListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of databases
         * @summary Gets a list of databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseListApi - functional programming interface
 * @export
 */
export const DatabaseListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseListApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of databases
         * @summary Gets a list of databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatabaseList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatabaseList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseListApi - factory interface
 * @export
 */
export const DatabaseListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseListApiFp(configuration)
    return {
        /**
         * Gets a list of databases
         * @summary Gets a list of databases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatabaseList(options?: any): AxiosPromise<DatabaseListResponse> {
            return localVarFp.getDatabaseList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseListApi - object-oriented interface
 * @export
 * @class DatabaseListApi
 * @extends {BaseAPI}
 */
export class DatabaseListApi extends BaseAPI {
    /**
     * Gets a list of databases
     * @summary Gets a list of databases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseListApi
     */
    public getDatabaseList(options?: any) {
        return DatabaseListApiFp(this.configuration).getDatabaseList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new document
         * @summary Creates a new document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {Document} document The document to create.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [parentid] Adds the document as a response to the document specified by the parent UNID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument: async (folder: string, database: string, authorization: string, document: Document, form?: string, computewithform?: boolean, parentid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('createDocument', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('createDocument', 'database', database)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createDocument', 'authorization', authorization)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('createDocument', 'document', document)
            const localVarPath = `/{folder}/{database}/api/data/documents`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (form !== undefined) {
                localVarQueryParameter['form'] = form;
            }

            if (computewithform !== undefined) {
                localVarQueryParameter['computewithform'] = computewithform;
            }

            if (parentid !== undefined) {
                localVarQueryParameter['parentid'] = parentid;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(document, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a document
         * @summary Deletes a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (folder: string, database: string, docUnid: string, authorization: string, ifUnmodifiedSince?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('deleteDocument', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('deleteDocument', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('deleteDocument', 'docUnid', docUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteDocument', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                localVarHeaderParameter['If-Unmodified-Since'] = String(ifUnmodifiedSince);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads a document
         * @summary Reads a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {boolean} [hidden] When &#x60;true&#x60;, emits hidden properties.  Hidden properties have names beginning with &#x60;$&#x60;, for example, &#x60;\&quot;$UpdatedBy\&quot;:\&quot;CN&#x3D;Admin/O&#x3D;Your Org\&quot;&#x60;. 
         * @param {boolean} [multipart] When &#x60;false&#x60;, formats rich text as a single HTML part rather than multipart. The default value is &#x60;true&#x60;. 
         * @param {boolean} [strongtype] When &#x60;true&#x60;, displays date-time items as objects with type and data elements. See the examples. Rich text items always use strongtype format. 
         * @param {boolean} [lowercasefields] When &#x60;true&#x60;, the reponse property names are all lower case. For example, a document item called &#x60;FirstName&#x60; is represented as &#x60;firstname&#x60; in the JSON response.  This parameter can help resolve issues caused by inconsistent naming of items across documents  (&#x60;FirstName&#x60; in one document and &#x60;FIRSTNAME&#x60; in another.) 
         * @param {string} [fields] Specifies the list of fields expected in the response.  For example, &#x60;fields&#x3D;FirstName,LastName&#x60; limits the JSON response to items matching those field names.  If the document includes items named &#x60;EMail&#x60; and  &#x60;Photo&#x60;, they are not included in the response.  Use this parameter to limit the size of the response. 
         * @param {boolean} [markread] When &#x60;false&#x60;, the document is not marked read for the authenticated user.  When &#x60;true&#x60;, the document is marked read.  When this parameter is omitted, the default value is &#x60;true&#x60;. 
         * @param {boolean} [attachmentlinks] When &#x60;true&#x60;, the response includes a link to each attachment instead of the attachment data itself.  You can access the attachment as a separate resource.  This parameter (&#x60;attachmentlinks&#x3D;true&#x60;) is mutually exclusive with &#x60;multipart&#x3D;false&#x60;. 
         * @param {string} [ifModifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: async (folder: string, database: string, docUnid: string, authorization: string, hidden?: boolean, multipart?: boolean, strongtype?: boolean, lowercasefields?: boolean, fields?: string, markread?: boolean, attachmentlinks?: boolean, ifModifiedSince?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getDocument', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getDocument', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('getDocument', 'docUnid', docUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getDocument', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }

            if (multipart !== undefined) {
                localVarQueryParameter['multipart'] = multipart;
            }

            if (strongtype !== undefined) {
                localVarQueryParameter['strongtype'] = strongtype;
            }

            if (lowercasefields !== undefined) {
                localVarQueryParameter['lowercasefields'] = lowercasefields;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (markread !== undefined) {
                localVarQueryParameter['markread'] = markread;
            }

            if (attachmentlinks !== undefined) {
                localVarQueryParameter['attachmentlinks'] = attachmentlinks;
            }

            if (ifModifiedSince !== undefined && ifModifiedSince !== null) {
                localVarHeaderParameter['If-Modified-Since'] = String(ifModifiedSince);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces all items in a document
         * @summary Replaces all items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument: async (folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('updateDocument', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('updateDocument', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('updateDocument', 'docUnid', docUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateDocument', 'authorization', authorization)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('updateDocument', 'document', document)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (form !== undefined) {
                localVarQueryParameter['form'] = form;
            }

            if (computewithform !== undefined) {
                localVarQueryParameter['computewithform'] = computewithform;
            }

            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                localVarHeaderParameter['If-Unmodified-Since'] = String(ifUnmodifiedSince);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(document, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates selected items in a document
         * @summary Updates selected items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentItems: async (folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('updateDocumentItems', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('updateDocumentItems', 'database', database)
            // verify required parameter 'docUnid' is not null or undefined
            assertParamExists('updateDocumentItems', 'docUnid', docUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateDocumentItems', 'authorization', authorization)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('updateDocumentItems', 'document', document)
            const localVarPath = `/{folder}/{database}/api/data/documents/unid/{docUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"docUnid"}}`, encodeURIComponent(String(docUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (form !== undefined) {
                localVarQueryParameter['form'] = form;
            }

            if (computewithform !== undefined) {
                localVarQueryParameter['computewithform'] = computewithform;
            }

            if (ifUnmodifiedSince !== undefined && ifUnmodifiedSince !== null) {
                localVarHeaderParameter['If-Unmodified-Since'] = String(ifUnmodifiedSince);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(document, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new document
         * @summary Creates a new document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {Document} document The document to create.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [parentid] Adds the document as a response to the document specified by the parent UNID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocument(folder: string, database: string, authorization: string, document: Document, form?: string, computewithform?: boolean, parentid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocument(folder, database, authorization, document, form, computewithform, parentid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a document
         * @summary Deletes a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(folder: string, database: string, docUnid: string, authorization: string, ifUnmodifiedSince?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(folder, database, docUnid, authorization, ifUnmodifiedSince, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads a document
         * @summary Reads a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {boolean} [hidden] When &#x60;true&#x60;, emits hidden properties.  Hidden properties have names beginning with &#x60;$&#x60;, for example, &#x60;\&quot;$UpdatedBy\&quot;:\&quot;CN&#x3D;Admin/O&#x3D;Your Org\&quot;&#x60;. 
         * @param {boolean} [multipart] When &#x60;false&#x60;, formats rich text as a single HTML part rather than multipart. The default value is &#x60;true&#x60;. 
         * @param {boolean} [strongtype] When &#x60;true&#x60;, displays date-time items as objects with type and data elements. See the examples. Rich text items always use strongtype format. 
         * @param {boolean} [lowercasefields] When &#x60;true&#x60;, the reponse property names are all lower case. For example, a document item called &#x60;FirstName&#x60; is represented as &#x60;firstname&#x60; in the JSON response.  This parameter can help resolve issues caused by inconsistent naming of items across documents  (&#x60;FirstName&#x60; in one document and &#x60;FIRSTNAME&#x60; in another.) 
         * @param {string} [fields] Specifies the list of fields expected in the response.  For example, &#x60;fields&#x3D;FirstName,LastName&#x60; limits the JSON response to items matching those field names.  If the document includes items named &#x60;EMail&#x60; and  &#x60;Photo&#x60;, they are not included in the response.  Use this parameter to limit the size of the response. 
         * @param {boolean} [markread] When &#x60;false&#x60;, the document is not marked read for the authenticated user.  When &#x60;true&#x60;, the document is marked read.  When this parameter is omitted, the default value is &#x60;true&#x60;. 
         * @param {boolean} [attachmentlinks] When &#x60;true&#x60;, the response includes a link to each attachment instead of the attachment data itself.  You can access the attachment as a separate resource.  This parameter (&#x60;attachmentlinks&#x3D;true&#x60;) is mutually exclusive with &#x60;multipart&#x3D;false&#x60;. 
         * @param {string} [ifModifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocument(folder: string, database: string, docUnid: string, authorization: string, hidden?: boolean, multipart?: boolean, strongtype?: boolean, lowercasefields?: boolean, fields?: string, markread?: boolean, attachmentlinks?: boolean, ifModifiedSince?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(folder, database, docUnid, authorization, hidden, multipart, strongtype, lowercasefields, fields, markread, attachmentlinks, ifModifiedSince, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces all items in a document
         * @summary Replaces all items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocument(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocument(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates selected items in a document
         * @summary Updates selected items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentItems(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentItems(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * Creates a new document
         * @summary Creates a new document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {Document} document The document to create.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [parentid] Adds the document as a response to the document specified by the parent UNID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(folder: string, database: string, authorization: string, document: Document, form?: string, computewithform?: boolean, parentid?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createDocument(folder, database, authorization, document, form, computewithform, parentid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a document
         * @summary Deletes a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(folder: string, database: string, docUnid: string, authorization: string, ifUnmodifiedSince?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocument(folder, database, docUnid, authorization, ifUnmodifiedSince, options).then((request) => request(axios, basePath));
        },
        /**
         * Reads a document
         * @summary Reads a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {boolean} [hidden] When &#x60;true&#x60;, emits hidden properties.  Hidden properties have names beginning with &#x60;$&#x60;, for example, &#x60;\&quot;$UpdatedBy\&quot;:\&quot;CN&#x3D;Admin/O&#x3D;Your Org\&quot;&#x60;. 
         * @param {boolean} [multipart] When &#x60;false&#x60;, formats rich text as a single HTML part rather than multipart. The default value is &#x60;true&#x60;. 
         * @param {boolean} [strongtype] When &#x60;true&#x60;, displays date-time items as objects with type and data elements. See the examples. Rich text items always use strongtype format. 
         * @param {boolean} [lowercasefields] When &#x60;true&#x60;, the reponse property names are all lower case. For example, a document item called &#x60;FirstName&#x60; is represented as &#x60;firstname&#x60; in the JSON response.  This parameter can help resolve issues caused by inconsistent naming of items across documents  (&#x60;FirstName&#x60; in one document and &#x60;FIRSTNAME&#x60; in another.) 
         * @param {string} [fields] Specifies the list of fields expected in the response.  For example, &#x60;fields&#x3D;FirstName,LastName&#x60; limits the JSON response to items matching those field names.  If the document includes items named &#x60;EMail&#x60; and  &#x60;Photo&#x60;, they are not included in the response.  Use this parameter to limit the size of the response. 
         * @param {boolean} [markread] When &#x60;false&#x60;, the document is not marked read for the authenticated user.  When &#x60;true&#x60;, the document is marked read.  When this parameter is omitted, the default value is &#x60;true&#x60;. 
         * @param {boolean} [attachmentlinks] When &#x60;true&#x60;, the response includes a link to each attachment instead of the attachment data itself.  You can access the attachment as a separate resource.  This parameter (&#x60;attachmentlinks&#x3D;true&#x60;) is mutually exclusive with &#x60;multipart&#x3D;false&#x60;. 
         * @param {string} [ifModifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(folder: string, database: string, docUnid: string, authorization: string, hidden?: boolean, multipart?: boolean, strongtype?: boolean, lowercasefields?: boolean, fields?: string, markread?: boolean, attachmentlinks?: boolean, ifModifiedSince?: string, options?: any): AxiosPromise<Document> {
            return localVarFp.getDocument(folder, database, docUnid, authorization, hidden, multipart, strongtype, lowercasefields, fields, markread, attachmentlinks, ifModifiedSince, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces all items in a document
         * @summary Replaces all items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDocument(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates selected items in a document
         * @summary Updates selected items in a document
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} docUnid Universal ID of the document.
         * @param {string} authorization 
         * @param {Document} document The document properties to update.
         * @param {string} [form] Associates a database form with the document. 
         * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
         * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentItems(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDocumentItems(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Creates a new document
     * @summary Creates a new document
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} authorization 
     * @param {Document} document The document to create.
     * @param {string} [form] Associates a database form with the document. 
     * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
     * @param {string} [parentid] Adds the document as a response to the document specified by the parent UNID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createDocument(folder: string, database: string, authorization: string, document: Document, form?: string, computewithform?: boolean, parentid?: string, options?: any) {
        return DocumentApiFp(this.configuration).createDocument(folder, database, authorization, document, form, computewithform, parentid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a document
     * @summary Deletes a document
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} authorization 
     * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocument(folder: string, database: string, docUnid: string, authorization: string, ifUnmodifiedSince?: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDocument(folder, database, docUnid, authorization, ifUnmodifiedSince, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads a document
     * @summary Reads a document
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} authorization 
     * @param {boolean} [hidden] When &#x60;true&#x60;, emits hidden properties.  Hidden properties have names beginning with &#x60;$&#x60;, for example, &#x60;\&quot;$UpdatedBy\&quot;:\&quot;CN&#x3D;Admin/O&#x3D;Your Org\&quot;&#x60;. 
     * @param {boolean} [multipart] When &#x60;false&#x60;, formats rich text as a single HTML part rather than multipart. The default value is &#x60;true&#x60;. 
     * @param {boolean} [strongtype] When &#x60;true&#x60;, displays date-time items as objects with type and data elements. See the examples. Rich text items always use strongtype format. 
     * @param {boolean} [lowercasefields] When &#x60;true&#x60;, the reponse property names are all lower case. For example, a document item called &#x60;FirstName&#x60; is represented as &#x60;firstname&#x60; in the JSON response.  This parameter can help resolve issues caused by inconsistent naming of items across documents  (&#x60;FirstName&#x60; in one document and &#x60;FIRSTNAME&#x60; in another.) 
     * @param {string} [fields] Specifies the list of fields expected in the response.  For example, &#x60;fields&#x3D;FirstName,LastName&#x60; limits the JSON response to items matching those field names.  If the document includes items named &#x60;EMail&#x60; and  &#x60;Photo&#x60;, they are not included in the response.  Use this parameter to limit the size of the response. 
     * @param {boolean} [markread] When &#x60;false&#x60;, the document is not marked read for the authenticated user.  When &#x60;true&#x60;, the document is marked read.  When this parameter is omitted, the default value is &#x60;true&#x60;. 
     * @param {boolean} [attachmentlinks] When &#x60;true&#x60;, the response includes a link to each attachment instead of the attachment data itself.  You can access the attachment as a separate resource.  This parameter (&#x60;attachmentlinks&#x3D;true&#x60;) is mutually exclusive with &#x60;multipart&#x3D;false&#x60;. 
     * @param {string} [ifModifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has been modified since the specified date. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocument(folder: string, database: string, docUnid: string, authorization: string, hidden?: boolean, multipart?: boolean, strongtype?: boolean, lowercasefields?: boolean, fields?: string, markread?: boolean, attachmentlinks?: boolean, ifModifiedSince?: string, options?: any) {
        return DocumentApiFp(this.configuration).getDocument(folder, database, docUnid, authorization, hidden, multipart, strongtype, lowercasefields, fields, markread, attachmentlinks, ifModifiedSince, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces all items in a document
     * @summary Replaces all items in a document
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} authorization 
     * @param {Document} document The document properties to update.
     * @param {string} [form] Associates a database form with the document. 
     * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
     * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocument(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any) {
        return DocumentApiFp(this.configuration).updateDocument(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates selected items in a document
     * @summary Updates selected items in a document
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} docUnid Universal ID of the document.
     * @param {string} authorization 
     * @param {Document} document The document properties to update.
     * @param {string} [form] Associates a database form with the document. 
     * @param {boolean} [computewithform] When &#x60;true&#x60;, runs the associated form formulas against the request data before posting the data. You must identify the form. 
     * @param {string} [ifUnmodifiedSince] Date and time in RFC 1123 time format (for example,  &#x60;Tue, 23 Aug 2011 21:35:18 GMT&#x60;) as previously returned in the  &#x60;Last-Modified&#x60; response header of a GET for the same document. the operation succeeds only if the document has not been modified since the specified date. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocumentItems(folder: string, database: string, docUnid: string, authorization: string, document: Document, form?: string, computewithform?: boolean, ifUnmodifiedSince?: string, options?: any) {
        return DocumentApiFp(this.configuration).updateDocumentItems(folder, database, docUnid, authorization, document, form, computewithform, ifUnmodifiedSince, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentListApi - axios parameter creator
 * @export
 */
export const DocumentListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you don\'t specify any query parameters, the response includes all the documents in the database.To limit the number of documents returned, use the optional `since` or `search` parameters.
         * @summary Gets a list of documents
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [since] Returns only documents modified since a specified time. Specify the time in ISO 8601 format.  For example, &#x60;2011-08-21T20:21:00Z&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments: async (folder: string, database: string, authorization: string, search?: string, searchmaxdocs?: number, since?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getDocuments', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getDocuments', 'database', database)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getDocuments', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/documents`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchmaxdocs !== undefined) {
                localVarQueryParameter['searchmaxdocs'] = searchmaxdocs;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentListApi - functional programming interface
 * @export
 */
export const DocumentListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentListApiAxiosParamCreator(configuration)
    return {
        /**
         * If you don\'t specify any query parameters, the response includes all the documents in the database.To limit the number of documents returned, use the optional `since` or `search` parameters.
         * @summary Gets a list of documents
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [since] Returns only documents modified since a specified time. Specify the time in ISO 8601 format.  For example, &#x60;2011-08-21T20:21:00Z&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocuments(folder: string, database: string, authorization: string, search?: string, searchmaxdocs?: number, since?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocuments(folder, database, authorization, search, searchmaxdocs, since, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentListApi - factory interface
 * @export
 */
export const DocumentListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentListApiFp(configuration)
    return {
        /**
         * If you don\'t specify any query parameters, the response includes all the documents in the database.To limit the number of documents returned, use the optional `since` or `search` parameters.
         * @summary Gets a list of documents
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [since] Returns only documents modified since a specified time. Specify the time in ISO 8601 format.  For example, &#x60;2011-08-21T20:21:00Z&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(folder: string, database: string, authorization: string, search?: string, searchmaxdocs?: number, since?: string, options?: any): AxiosPromise<DocumentListResponse> {
            return localVarFp.getDocuments(folder, database, authorization, search, searchmaxdocs, since, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentListApi - object-oriented interface
 * @export
 * @class DocumentListApi
 * @extends {BaseAPI}
 */
export class DocumentListApi extends BaseAPI {
    /**
     * If you don\'t specify any query parameters, the response includes all the documents in the database.To limit the number of documents returned, use the optional `since` or `search` parameters.
     * @summary Gets a list of documents
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} authorization 
     * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
     * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
     * @param {string} [since] Returns only documents modified since a specified time. Specify the time in ISO 8601 format.  For example, &#x60;2011-08-21T20:21:00Z&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentListApi
     */
    public getDocuments(folder: string, database: string, authorization: string, search?: string, searchmaxdocs?: number, since?: string, options?: any) {
        return DocumentListApiFp(this.configuration).getDocuments(folder, database, authorization, search, searchmaxdocs, since, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the contents of a folder by folder name
         * @summary Updates the contents of a folder by folder name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderContentByName: async (folder: string, database: string, viewName: string, authorization: string, operations: FolderOperations, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('updateFolderContentByName', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('updateFolderContentByName', 'database', database)
            // verify required parameter 'viewName' is not null or undefined
            assertParamExists('updateFolderContentByName', 'viewName', viewName)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateFolderContentByName', 'authorization', authorization)
            // verify required parameter 'operations' is not null or undefined
            assertParamExists('updateFolderContentByName', 'operations', operations)
            const localVarPath = `/{folder}/{database}/api/data/collections/name/{viewName}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewName"}}`, encodeURIComponent(String(viewName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the contents of a folder by folder UNID
         * @summary Updates the contents of a folder by folder UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderContentByUnid: async (folder: string, database: string, viewUnid: string, authorization: string, operations: FolderOperations, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('updateFolderContentByUnid', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('updateFolderContentByUnid', 'database', database)
            // verify required parameter 'viewUnid' is not null or undefined
            assertParamExists('updateFolderContentByUnid', 'viewUnid', viewUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateFolderContentByUnid', 'authorization', authorization)
            // verify required parameter 'operations' is not null or undefined
            assertParamExists('updateFolderContentByUnid', 'operations', operations)
            const localVarPath = `/{folder}/{database}/api/data/collections/unid/{viewUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewUnid"}}`, encodeURIComponent(String(viewUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the contents of a folder by folder name
         * @summary Updates the contents of a folder by folder name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderContentByName(folder: string, database: string, viewName: string, authorization: string, operations: FolderOperations, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderContentByName(folder, database, viewName, authorization, operations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the contents of a folder by folder UNID
         * @summary Updates the contents of a folder by folder UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderContentByUnid(folder: string, database: string, viewUnid: string, authorization: string, operations: FolderOperations, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderContentByUnid(folder, database, viewUnid, authorization, operations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FolderApi - factory interface
 * @export
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderApiFp(configuration)
    return {
        /**
         * Updates the contents of a folder by folder name
         * @summary Updates the contents of a folder by folder name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderContentByName(folder: string, database: string, viewName: string, authorization: string, operations: FolderOperations, options?: any): AxiosPromise<void> {
            return localVarFp.updateFolderContentByName(folder, database, viewName, authorization, operations, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the contents of a folder by folder UNID
         * @summary Updates the contents of a folder by folder UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a folder in the database.
         * @param {string} authorization 
         * @param {FolderOperations} operations Documents to be added and/or removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderContentByUnid(folder: string, database: string, viewUnid: string, authorization: string, operations: FolderOperations, options?: any): AxiosPromise<void> {
            return localVarFp.updateFolderContentByUnid(folder, database, viewUnid, authorization, operations, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
export class FolderApi extends BaseAPI {
    /**
     * Updates the contents of a folder by folder name
     * @summary Updates the contents of a folder by folder name
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewName Name of a folder in the database.
     * @param {string} authorization 
     * @param {FolderOperations} operations Documents to be added and/or removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public updateFolderContentByName(folder: string, database: string, viewName: string, authorization: string, operations: FolderOperations, options?: any) {
        return FolderApiFp(this.configuration).updateFolderContentByName(folder, database, viewName, authorization, operations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the contents of a folder by folder UNID
     * @summary Updates the contents of a folder by folder UNID
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewUnid Universal ID of a folder in the database.
     * @param {string} authorization 
     * @param {FolderOperations} operations Documents to be added and/or removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public updateFolderContentByUnid(folder: string, database: string, viewUnid: string, authorization: string, operations: FolderOperations, options?: any) {
        return FolderApiFp(this.configuration).updateFolderContentByUnid(folder, database, viewUnid, authorization, operations, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewDesignApi - axios parameter creator
 * @export
 */
export const ViewDesignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewDesignByName: async (folder: string, database: string, viewName: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getViewDesignByName', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getViewDesignByName', 'database', database)
            // verify required parameter 'viewName' is not null or undefined
            assertParamExists('getViewDesignByName', 'viewName', viewName)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getViewDesignByName', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/collections/name/{viewName}/design`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewName"}}`, encodeURIComponent(String(viewName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewDesignByUnid: async (folder: string, database: string, viewUnid: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getViewDesignByUnid', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getViewDesignByUnid', 'database', database)
            // verify required parameter 'viewUnid' is not null or undefined
            assertParamExists('getViewDesignByUnid', 'viewUnid', viewUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getViewDesignByUnid', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/collections/unid/{viewUnid}/design`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewUnid"}}`, encodeURIComponent(String(viewUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewDesignApi - functional programming interface
 * @export
 */
export const ViewDesignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewDesignApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewDesignByName(folder: string, database: string, viewName: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewDesignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewDesignByName(folder, database, viewName, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewDesignByUnid(folder: string, database: string, viewUnid: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewDesignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewDesignByUnid(folder, database, viewUnid, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewDesignApi - factory interface
 * @export
 */
export const ViewDesignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewDesignApiFp(configuration)
    return {
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewDesignByName(folder: string, database: string, viewName: string, authorization: string, options?: any): AxiosPromise<ViewDesignResponse> {
            return localVarFp.getViewDesignByName(folder, database, viewName, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information on the columns in a view or folder
         * @summary Gets information on the columns in a view or folder
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewDesignByUnid(folder: string, database: string, viewUnid: string, authorization: string, options?: any): AxiosPromise<ViewDesignResponse> {
            return localVarFp.getViewDesignByUnid(folder, database, viewUnid, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewDesignApi - object-oriented interface
 * @export
 * @class ViewDesignApi
 * @extends {BaseAPI}
 */
export class ViewDesignApi extends BaseAPI {
    /**
     * Gets information on the columns in a view or folder
     * @summary Gets information on the columns in a view or folder
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewName Name of a view or folder in the database.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDesignApi
     */
    public getViewDesignByName(folder: string, database: string, viewName: string, authorization: string, options?: any) {
        return ViewDesignApiFp(this.configuration).getViewDesignByName(folder, database, viewName, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information on the columns in a view or folder
     * @summary Gets information on the columns in a view or folder
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewUnid Universal ID of a view or folder in the database.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewDesignApi
     */
    public getViewDesignByUnid(folder: string, database: string, viewUnid: string, authorization: string, options?: any) {
        return ViewDesignApiFp(this.configuration).getViewDesignByUnid(folder, database, viewUnid, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewEntryListApi - axios parameter creator
 * @export
 */
export const ViewEntryListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of view entries by view name
         * @summary Gets a list of view entries by view name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewEntriesByName: async (folder: string, database: string, viewName: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getViewEntriesByName', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getViewEntriesByName', 'database', database)
            // verify required parameter 'viewName' is not null or undefined
            assertParamExists('getViewEntriesByName', 'viewName', viewName)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getViewEntriesByName', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/collections/name/{viewName}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewName"}}`, encodeURIComponent(String(viewName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ps !== undefined) {
                localVarQueryParameter['ps'] = ps;
            }

            if (entrycount !== undefined) {
                localVarQueryParameter['entrycount'] = entrycount;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchmaxdocs !== undefined) {
                localVarQueryParameter['searchmaxdocs'] = searchmaxdocs;
            }

            if (sortcolumn !== undefined) {
                localVarQueryParameter['sortcolumn'] = sortcolumn;
            }

            if (sortorder !== undefined) {
                localVarQueryParameter['sortorder'] = sortorder;
            }

            if (startkeys !== undefined) {
                localVarQueryParameter['startkeys'] = startkeys;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            if (keysexactmatch !== undefined) {
                localVarQueryParameter['keysexactmatch'] = keysexactmatch;
            }

            if (expandlevel !== undefined) {
                localVarQueryParameter['expandlevel'] = expandlevel;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (parentid !== undefined) {
                localVarQueryParameter['parentid'] = parentid;
            }

            if (systemcolumns !== undefined) {
                localVarQueryParameter['systemcolumns'] = systemcolumns;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of view entries by view UNID
         * @summary Gets a list of view entries by view UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewEntriesByUnid: async (folder: string, database: string, viewUnid: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getViewEntriesByUnid', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getViewEntriesByUnid', 'database', database)
            // verify required parameter 'viewUnid' is not null or undefined
            assertParamExists('getViewEntriesByUnid', 'viewUnid', viewUnid)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getViewEntriesByUnid', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/collections/unid/{viewUnid}`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)))
                .replace(`{${"viewUnid"}}`, encodeURIComponent(String(viewUnid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (ps !== undefined) {
                localVarQueryParameter['ps'] = ps;
            }

            if (entrycount !== undefined) {
                localVarQueryParameter['entrycount'] = entrycount;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchmaxdocs !== undefined) {
                localVarQueryParameter['searchmaxdocs'] = searchmaxdocs;
            }

            if (sortcolumn !== undefined) {
                localVarQueryParameter['sortcolumn'] = sortcolumn;
            }

            if (sortorder !== undefined) {
                localVarQueryParameter['sortorder'] = sortorder;
            }

            if (startkeys !== undefined) {
                localVarQueryParameter['startkeys'] = startkeys;
            }

            if (keys !== undefined) {
                localVarQueryParameter['keys'] = keys;
            }

            if (keysexactmatch !== undefined) {
                localVarQueryParameter['keysexactmatch'] = keysexactmatch;
            }

            if (expandlevel !== undefined) {
                localVarQueryParameter['expandlevel'] = expandlevel;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (parentid !== undefined) {
                localVarQueryParameter['parentid'] = parentid;
            }

            if (systemcolumns !== undefined) {
                localVarQueryParameter['systemcolumns'] = systemcolumns;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewEntryListApi - functional programming interface
 * @export
 */
export const ViewEntryListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewEntryListApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of view entries by view name
         * @summary Gets a list of view entries by view name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewEntriesByName(folder: string, database: string, viewName: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewEntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewEntriesByName(folder, database, viewName, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of view entries by view UNID
         * @summary Gets a list of view entries by view UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewEntriesByUnid(folder: string, database: string, viewUnid: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewEntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewEntriesByUnid(folder, database, viewUnid, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewEntryListApi - factory interface
 * @export
 */
export const ViewEntryListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewEntryListApiFp(configuration)
    return {
        /**
         * Gets a list of view entries by view name
         * @summary Gets a list of view entries by view name
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewName Name of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewEntriesByName(folder: string, database: string, viewName: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any): AxiosPromise<ViewEntryListResponse> {
            return localVarFp.getViewEntriesByName(folder, database, viewName, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of view entries by view UNID
         * @summary Gets a list of view entries by view UNID
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} viewUnid Universal ID of a view or folder in the database.
         * @param {string} authorization 
         * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
         * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
         * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
         * @param {number} [ps] Page size or the number of entries to return. 
         * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
         * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
         * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
         * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
         * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
         * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
         * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
         * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
         * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
         * @param {string} [category] Returns only entries in a specified category. 
         * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
         * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewEntriesByUnid(folder: string, database: string, viewUnid: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any): AxiosPromise<ViewEntryListResponse> {
            return localVarFp.getViewEntriesByUnid(folder, database, viewUnid, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewEntryListApi - object-oriented interface
 * @export
 * @class ViewEntryListApi
 * @extends {BaseAPI}
 */
export class ViewEntryListApi extends BaseAPI {
    /**
     * Gets a list of view entries by view name
     * @summary Gets a list of view entries by view name
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewName Name of a view or folder in the database.
     * @param {string} authorization 
     * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
     * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
     * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
     * @param {number} [ps] Page size or the number of entries to return. 
     * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
     * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
     * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
     * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
     * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
     * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
     * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
     * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
     * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
     * @param {string} [category] Returns only entries in a specified category. 
     * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
     * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewEntryListApi
     */
    public getViewEntriesByName(folder: string, database: string, viewName: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any) {
        return ViewEntryListApiFp(this.configuration).getViewEntriesByName(folder, database, viewName, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of view entries by view UNID
     * @summary Gets a list of view entries by view UNID
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} viewUnid Universal ID of a view or folder in the database.
     * @param {string} authorization 
     * @param {number} [start] Specifies the starting entry. Defaults to 0 (the first entry). 
     * @param {number} [count] Specifies the number of entries to return. Defaults to 10. Note: Use &#x60;start&#x60; and &#x60;count&#x60; together, or use &#x60;ps&#x60; and  &#x60;page&#x60; together. 
     * @param {number} [page] Page number. The API returns entries based on a multiple of this parameter and the page size parameter (&#x60;ps&#x60;). 
     * @param {number} [ps] Page size or the number of entries to return. 
     * @param {boolean} [entrycount] When &#x60;false&#x60;, disable the output of the &#x60;Content-Range&#x60; header as a performance optimization. The default value is &#x60;true&#x60;. 
     * @param {string} [search] Returns only documents that match a full-text query. An error occurs if the database is not full-text indexed. 
     * @param {number} [searchmaxdocs] Limits the number of documents returned by a full-text search. 
     * @param {string} [sortcolumn] Returns entries sorted on a column. If the column is not sorted by design or does not exist, this parameter has no effect. 
     * @param {'ascending' | 'descending'} [sortorder] Specifies the sort order. The parameter value should be either &#x60;ascending&#x60; or &#x60;descending&#x60;. Pair this parameter with &#x60;sortcolumn&#x60;. 
     * @param {string} [startkeys] Returns sorted entries starting at a specified entry. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;startkeys&#x3D;Document0020&#x60; 
     * @param {string} [keys] Returns entries whose initial characters match keys. Pair this parameter with sortcolumn. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&#x60; 
     * @param {boolean} [keysexactmatch] Returns entries that match keys exactly. Pair this parameter with keys. Example: &#x60;?sortcolumn&#x3D;Title&amp;sortorder&#x3D;ascending&amp;keys&#x3D;Document001&amp;keysexactmatch&#x3D;true&#x60; 
     * @param {number} [expandlevel] Returns only entries at a specified indent level or higher. 
     * @param {string} [category] Returns only entries in a specified category. 
     * @param {string} [parentid] Returns only entries that are descendants of the specified entry UNID. Example: &#x60;parentid&#x3D;9B8F4A02A5F5254E852578950064EC03&#x60; 
     * @param {number} [systemcolumns] Limits system data to &#x60;@entryid&#x60; plus a bit mask formed by adding bit  values from the response properties table. Use hexadecimal or decimal.  For example, &#x60;systemcolumns&#x3D;0x80a&#x60; returns only &#x60;@entryid&#x60;, &#x60;@unid&#x60;,  &#x60;@read&#x60;, and &#x60;@href&#x60;. In decimal format, &#x60;systemcolumns&#x3D;2058&#x60; has the  same effect. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewEntryListApi
     */
    public getViewEntriesByUnid(folder: string, database: string, viewUnid: string, authorization: string, start?: number, count?: number, page?: number, ps?: number, entrycount?: boolean, search?: string, searchmaxdocs?: number, sortcolumn?: string, sortorder?: 'ascending' | 'descending', startkeys?: string, keys?: string, keysexactmatch?: boolean, expandlevel?: number, category?: string, parentid?: string, systemcolumns?: number, options?: any) {
        return ViewEntryListApiFp(this.configuration).getViewEntriesByUnid(folder, database, viewUnid, authorization, start, count, page, ps, entrycount, search, searchmaxdocs, sortcolumn, sortorder, startkeys, keys, keysexactmatch, expandlevel, category, parentid, systemcolumns, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ViewListApi - axios parameter creator
 * @export
 */
export const ViewListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of views and folders in a database
         * @summary Gets a list of views and folders in a database
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewList: async (folder: string, database: string, authorization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getViewList', 'folder', folder)
            // verify required parameter 'database' is not null or undefined
            assertParamExists('getViewList', 'database', database)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getViewList', 'authorization', authorization)
            const localVarPath = `/{folder}/{database}/api/data/collections`
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)))
                .replace(`{${"database"}}`, encodeURIComponent(String(database)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewListApi - functional programming interface
 * @export
 */
export const ViewListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ViewListApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of views and folders in a database
         * @summary Gets a list of views and folders in a database
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewList(folder: string, database: string, authorization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewList(folder, database, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ViewListApi - factory interface
 * @export
 */
export const ViewListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ViewListApiFp(configuration)
    return {
        /**
         * Gets a list of views and folders in a database
         * @summary Gets a list of views and folders in a database
         * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
         * @param {string} database Database file name.
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewList(folder: string, database: string, authorization: string, options?: any): AxiosPromise<ViewListResponse> {
            return localVarFp.getViewList(folder, database, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ViewListApi - object-oriented interface
 * @export
 * @class ViewListApi
 * @extends {BaseAPI}
 */
export class ViewListApi extends BaseAPI {
    /**
     * Gets a list of views and folders in a database
     * @summary Gets a list of views and folders in a database
     * @param {string} folder Database folder name relative to the Domino data directory.  If the database is not in a folder, use &#x60;.&#x60; to specify the data directory itself. 
     * @param {string} database Database file name.
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewListApi
     */
    public getViewList(folder: string, database: string, authorization: string, options?: any) {
        return ViewListApiFp(this.configuration).getViewList(folder, database, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


